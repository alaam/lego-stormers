{"main":"from hub import light_matrix, motion_sensor, sound\nimport runloop, sys\nimport motor_pair\nimport motor\nimport color_sensor\nimport math\nimport time\nfrom hub import port\n#latest all missions are merged -Ayesha\n# Record the start time when the program begins\nstart_time = time.ticks_ms()\n\ndef myprint(*args, **kwargs):\n    # Calculate the elapsed time since the program started\n    elapsed_ms = time.ticks_diff(time.ticks_ms(), start_time)\n\n    # Convert milliseconds to minutes, seconds, and milliseconds\n    total_seconds = elapsed_ms // 1000\n    millis = elapsed_ms % 1000\n    minutes = total_seconds // 60\n    seconds = total_seconds % 60\n\n    # Format the timestamp as MM:SS.mmm\n    timestamp = '{:02d}:{:02d}.{:03d}'.format(minutes, seconds, millis)\n\n    # Combine all positional arguments into a single string\n    message = ' '.join(str(arg) for arg in args)\n\n    # Print the timestamp followed by the original message\n    print('{}: {}'.format(timestamp, message))\n\n\ndef myprint_(*args, **kwargs):\n    #pass\n    print(args,kwargs)\n\nclass PIDController:\n    def __init__(self, Kp, Ki, Kd):\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.prev_error = 0\n        self.integral = 0\n\n\n    def calculate(self, error):\n        self.integral += error\n        derivative = error - self.prev_error\n        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative\n        self.prev_error = error\n        return output\n\n\ndef is_stable () -> bool:\n    #myprint(\"accy\", motion_sensor.acceleration(True)[0],\"accy:\", motion_sensor.acceleration(True)[1],\"accz:\", motion_sensor.acceleration(True)[2])\n    return (motion_sensor.acceleration(True)[0] <100)\n    #+ motion_sensor.acceleration(True)[1])==0\n\nclass FLLBaseLib:\n    def __init__(self,cfg=None):\n        if cfg==None:\n            cfg={\n                \"left_wheel_port\":port.B,\n                \"right_wheel_port\":port.A,\n                \"first_color_sensor_port\":port.F,\n                \"second_color_sensor_port\":port.E,\n                \"first_arm_port\":port.C,\n                \"second_arm_port\":port.D,\n                \"first_arm_motor_position\":\"\",\n                \"second_arm_motor_position\":\"\"\n                }\n\n        self.cfg=cfg\n        self.left_wheel_port = cfg[\"left_wheel_port\"] #port.B\n        self.right_wheel_port = cfg[\"right_wheel_port\"] #port.A\n        self.first_color_sensor_port = cfg[\"first_color_sensor_port\"] #port.F\n        self.second_color_sensor_port = cfg[\"second_color_sensor_port\"] #port.E\n        self.first_arm_port = cfg[\"first_arm_port\"] #port.D\n        self.second_arm_port = cfg[\"second_arm_port\"] #port.C\n        self.first_arm_after_reset_initialized=True\n        self.second_arm_after_reset_initialized=True\n        self.first_arm_init_deg = motor.absolute_position(self.first_arm_port)\n        motor_pair.pair(motor_pair.PAIR_1,self.left_wheel_port,self.right_wheel_port)\n        motion_sensor.set_yaw_face(motion_sensor.FRONT)\n        ret=self.reset_yaw(0)\n\n\n    # cm, this is a constant for your robot\n    WHEEL_CIRCUMFERENCE = 17.5\n    TRACK = 8 #11.2 # cm - please measure your own robot.\n\n\n    def follow_line(self,time_to_follow_in_ms):\n        # Initialize PID controller with appropriate constants\n        pid_controller = PIDController(Kp=0.1, Ki=0.01, Kd=0.05)\n\n\n        # Set a base motor speed (adjust based on your requirements)\n        base_speed = 30\n        start_time=time.ticks_ms()\n        # Example line-following loop\n        while time.ticks_ms()-start_time < time_to_follow_in_ms:\n            sensor_value = color_sensor.reflection(self.first_color_sensor_port)\n            steering=math.floor(3/5)*sensor_value+base_speed\n            # Setpoint is the center sensor value when the robot is perfectly on the line\n            setpoint = 31\n\n\n            # Calculate the error\n            error = setpoint - sensor_value\n            # Use PID controller to get the correction value\n            pid_output = pid_controller.calculate(error)\n\n\n            #myprint(\"steering:\",steering)\n            #myprint(\"time_elapsed:\",time.ticks_ms()-start_time,\" given:\",time_to_follow_in_ms)\n            motor_pair.move(motor_pair.PAIR_1,math.floor(pid_output),velocity=100)\n            #motor.run(self.right_wheel_port,math.floor(base_speed-pid_output),acceleration=100)\n            #motor.run(self.left_wheel_port,math.floor(base_speed+pid_output),acceleration=100)\n        motor_pair.stop(motor_pair.PAIR_1)\n        motor.stop(self.left_wheel_port)\n        motor.stop(self.right_wheel_port)\n        myprint(\"follow line done,\", time.ticks_ms()-start_time)\n\n\n\n\n    # input must be in the same unit as WHEEL_CIRCUMFERENCE\n    def deg_for_dist(self,distance_cm):\n        # Add multiplier for gear ratio if needed\n        return int((distance_cm/FLLBaseLib.WHEEL_CIRCUMFERENCE) * 360)\n\n\n    async def move(self,distance_in_cm,velo=360,steer=0,correct_error=False):\n        distance_in_deg=self.deg_for_dist(distance_in_cm)\n        sa=0\n        if correct_error:\n            await self.reset_yaw(0)\n            sa=max(.1,self.get_360_mapped_yaw())\n\n        await motor_pair.move_for_degrees(motor_pair.PAIR_1,distance_in_deg,steer,velocity=velo,stop=motor.BRAKE, acceleration=1000)\n\n        if correct_error:\n            ea=self.get_360_mapped_yaw(stablize_first=True)\n            ed=self.compute_error(sa,ea,sa,requested_deg_per_achived=0,hw_err_threshold=150)\n            ed = ed * (-1 if distance_in_cm<0 else 1)\n            await self.turn_using_gyro(ed,speed=50,correct_error=False)\n\n\n    async def reset_yaw(self,offset=0):\n        #check_stable = lambda : (( motion_sensor.acceleration(True)[0] + motion_sensor.acceleration(True)[1] ) ==0 )\n        #await runloop.until(is_stable)\n        await runloop.sleep_ms(65)\n        motion_sensor.reset_yaw(offset)\n        await runloop.sleep_ms(65)\n        #await runloop.until(motion_sensor.acceleration)\n\n    def get_360_mapped_yaw(self,stablize_first=False):\n        if stablize_first:\n            time.sleep(0.065)\n        cy=motion_sensor.tilt_angles()[0]\n        #if (cy<0): return cy+3600\n        return cy/10\n\n    async def turn_using_gyro(self,deg,speed=200,correct_error=False):\n        self.cur_turn_deg=deg\n        await self.reset_yaw(0)\n        turn = -100 if deg<0 else 100\n\n        start_yaw_angle=self.get_360_mapped_yaw(stablize_first=True) #motion_sensor.tilt_angles()[0]\n        curr=self.get_360_mapped_yaw() #motion_sensor.tilt_angles()[0]\n        diff = abs(curr)-abs(start_yaw_angle)\n        myprint(\"from yaw:\",curr, \" start_yaw_angle:\",start_yaw_angle,\" diff:\",diff, \"asked:\",deg*10)\n        if True:\n            motor_pair.move(motor_pair.PAIR_1,turn,velocity=speed)\n        else:\n            if deg < 0: #left turn\n                motor.run(self.left_wheel_port,speed)\n            else:\n                motor.run(self.right_wheel_port,-speed)\n\n        count=1\n        requested_deg_per_achived= 1 if correct_error else 1\n        while abs(diff) < abs(deg)*requested_deg_per_achived: #yaw is decidegree hence multiply incoming angle by 10\n            #await runloop.sleep_ms(1)\n            #myprint(\"from yaw:\",abs(curr), \" start_yaw_angle:\",abs(start_yaw_angle),\" diff:\",abs(diff), \"asked:\",abs(deg*10))\n            curr=self.get_360_mapped_yaw() #motion_sensor.tilt_angles()[0]\n            diff = abs(curr)-abs(start_yaw_angle)\n            count+=1\n        motor_pair.stop(motor_pair.PAIR_1,stop=motor.BRAKE)\n        #myprint(\"after loop yaw:\",motion_sensor.tilt_angles()[0])\n        #await runloop.sleep_ms(200)\n        ea=self.get_360_mapped_yaw(stablize_first=True) #motion_sensor.tilt_angles()[0]\n        myprint(\"after 200ms yaw ea:\",ea,\" loop count:\",count)\n        sa=start_yaw_angle\n        if correct_error:\n            ed=self.compute_error(sa,ea,deg,requested_deg_per_achived)\n            myprint(\"gyro: degrees:\",deg,\"ea:\",ea,\" sa:\",sa, \"error correction:\",ed)\n            await self.turn_using_gyro(ed,speed=100,correct_error=False)\n        myprint(\"end yaw:\",ea)\n\n\n    async def turn(self,deg):\n        motion_sensor.set_yaw_face(motion_sensor.FRONT)\n        await self.reset_yaw(0)\n        myprint(\"start yaw:\",self.get_360_mapped_yaw())\n        if deg<0:\n            await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1,deg,0,100,acceleration=100)\n        else:\n            await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1,deg,100,0,acceleration=100)\n        myprint(\"end yaw:\",self.get_360_mapped_yaw(stablize_first=True))\n\n\n    def compute_error(self,gyro_starta,gyro_enda,requested_deg,requested_deg_per_achived,hw_err_threshold=0.3):\n        ea=gyro_enda\n        sa=gyro_starta\n        degrees=requested_deg\n        ed=abs(abs(ea)-abs(sa))-abs(degrees)\n        if (abs(ed)>abs(degrees)*hw_err_threshold): #only correct 30% of error ; assuming beyond 30% is malfunction of hw but visibly its not\n            myprint(\"compute error: HW mal function: degrees:\",degrees,\"ea:\",ea,\" sa:\",sa, \"error correction:\",ed)\n            if (ed<0):\n                ed=-abs(degrees)*(1-requested_deg_per_achived)\n            else:\n                ed=abs(degrees)*(1-requested_deg_per_achived)\n            #ed=0 #not doing error correction if error is more than 30%\n\n        if ed<0: #under run\n            ed = ed * (-1 if degrees < 0 else 1)\n        else: #over run\n            ed = ed * (1 if degrees < 0 else -1) #reverse the direct\n        myprint(\"compute error: degrees:\",degrees,\"ea:\",ea,\" sa:\",sa, \"error correction:\",ed)\n        return ed\n\n    async def spin_turn(self,degrees, mspeed=200,correct_error=False):\n        #motion_sensor.set_yaw_face(motion_sensor.FRONT)\n        await self.reset_yaw(0)\n\n        sa=self.get_360_mapped_yaw() #(motion_sensor.tilt_angles()[0])/10\n\n        myprint(\"start yaw:\",sa,\" deg requsted:\",degrees)\n\n\n        SPIN_CIRCUMFERENCE = FLLBaseLib.TRACK * math.pi\n        ed=0\n#        while ed or degrees:\n        # Add a multiplier for gear ratios if youâ€™re using gears\n        requested_deg_per_achived= 1 if correct_error else 1\n        mot_degrees = int((SPIN_CIRCUMFERENCE/FLLBaseLib.WHEEL_CIRCUMFERENCE) * abs(degrees)*requested_deg_per_achived)\n        if degrees > 0:\n            # spin clockwise\n            await motor_pair.move_for_degrees(motor_pair.PAIR_1, mot_degrees, 100, velocity=mspeed)\n        else:\n            #spin counter clockwise\n            await motor_pair.move_for_degrees(motor_pair.PAIR_1, mot_degrees, -100, velocity=mspeed)\n        #await runloop.sleep_ms(150)\n        ea=self.get_360_mapped_yaw(stablize_first=True) #(motion_sensor.tilt_angles()[0])/10\n\n        if correct_error:\n            ed=self.compute_error(sa,ea,degrees,requested_deg_per_achived)\n            myprint(\"spin: degrees:\",degrees,\"ea:\",ea,\" sa:\",sa, \"error correction:\",ed)\n            #await self.spin_turn(ed,correct_error=False,mspeed=100)\n            await self.turn_using_gyro(ed,speed=50,correct_error=False)\n\n\n        if False and correct_error:\n            ed=abs(degrees)-abs(abs(ea)-abs(sa))\n            #ed = ed * -1 if degrees < 0 else 1\n            myprint(\"degrees:\",degrees,\"ea:\",ea,\" sa:\",sa, \"error correction:\",ed)\n            await self.spin_turn(ed,correct_error=False,mspeed=100)\n        myprint(\"end yaw:\",ea)\n\n\n    async def pivot_turn(self, robot_degrees, motor_speed=200):\n        PIVOT_CIRCUMFERENCE = 2 *FLLBaseLib.TRACK * math.pi\n        # Add a multiplier for gear ratios if youâ€™re using gears\n        motor_degrees = int((PIVOT_CIRCUMFERENCE/ FLLBaseLib.WHEEL_CIRCUMFERENCE) * abs(robot_degrees))\n        if robot_degrees > 0:\n            # pivot clockwise\n            await motor_pair.move_for_degrees(motor_pair.PAIR_1, motor_degrees, 50, velocity=motor_speed)\n        else:\n            #pivot counter clockwise\n            await motor_pair.move_for_degrees(motor_pair.PAIR_1, motor_degrees, -50, velocity=motor_speed)\n\n\n    async def move_backward(self,distance_in_cm,velo=360,steer=0):\n        await self.move(-distance_in_cm,velo=velo,steer=steer)\n\n\n    async def move_forward(self,distance_in_cm,velo=360,steer=0):\n        await self.move(distance_in_cm,velo=velo,steer=steer)\n\n\n    async def turn_right(self,deg,speed=200,use_gyro=False,correct_error=False): #200\n        if use_gyro==False:\n            await self.spin_turn(deg,speed,correct_error=correct_error)\n            #await self.pivot_turn(deg,speed)\n        else:\n            await self.turn_using_gyro(deg,speed,correct_error=correct_error)\n\n\n    async def turn_left(self,deg,speed=200,use_gyro=False,correct_error=False): #200\n        if use_gyro==False:\n            await self.spin_turn(-deg,speed,correct_error=correct_error)\n            #await self.pivot_turn(-deg,speed)\n        else:\n            await self.turn_using_gyro(-deg,speed,correct_error=correct_error)\n\n    async def _arm_reset(self,port,angle_overdrive,initial_postition_deg,speed):\n        #In motor.run_for_degrees function, positive deg spins counter-clock and negative deg spins counter-clock\n        print_motor_feedback=False\n        cp=motor.absolute_position(port)\n        rp=motor.relative_position(port)\n        myprint(\"_arm_reset port:\",port,\" before ap:\",cp, \" rp:\",rp)\n        ret=await motor.run_for_degrees(port, angle_overdrive, speed)\n        if print_motor_feedback:\n            await self.sleep(500)\n            cp=motor.absolute_position(port)\n            rp=motor.relative_position(port)\n        myprint(\"After angle overdrive ap:\",cp, \" rp:\",rp)\n        motor.reset_relative_position(port,0)\n        odsign= -1 if angle_overdrive<0 else 1\n        ipd=abs(initial_postition_deg)*-odsign\n        ret=await motor.run_for_degrees(port, ipd, speed)\n        if print_motor_feedback:\n            await self.sleep(500)\n            cp=motor.absolute_position(port)\n            rp=motor.relative_position(port)\n        myprint(\"After reset rp ap:\",cp, \" rp:\",rp)\n        #await sound.beep()\n        pass\n\n    async def _arm_reset_top_left(self,port,angle_overdrive=359,initial_postition_deg=150,speed=700):\n        await self._arm_reset(port,angle_overdrive,initial_postition_deg,speed)\n\n    async def _arm_reset_top_right(self,port,angle_overdrive=359,initial_postition_deg=150,speed=700):\n        await self._arm_reset(port,-angle_overdrive,initial_postition_deg,speed)\n\n    async def _arm_reset_back_left(self,port,angle_overdrive=359,initial_postition_deg=150,speed=700):\n        await self._arm_reset(port,-angle_overdrive,initial_postition_deg,speed)\n\n    async def _arm_reset_back_right(self,port,angle_overdrive=359,initial_postition_deg=150,speed=700):\n        await self._arm_reset(port,angle_overdrive,initial_postition_deg,speed)\n\n    async def _arm_reset_left_left(self,port,angle_overdrive=359,initial_postition_deg=150,speed=700):\n        await self._arm_reset(port,-angle_overdrive,initial_postition_deg,speed)\n\n    async def move_arm_relative(self,port,deg,speed):\n        #In positive deg spins counter-clock and negative deg spins counter-clock\n        ret=await motor.run_for_degrees(port, deg, speed)\n\n    async def second_arm_reset(self,initial_position=True):\n        self.second_arm_after_reset_initialized=initial_position\n        initial_pos_angle=150 if initial_position else 0\n        if self.cfg[\"second_arm_motor_position\"]==\"top_left\":\n            await self._arm_reset_top_left(self.second_arm_port,initial_postition_deg=initial_pos_angle)\n        elif self.cfg[\"second_arm_motor_position\"]==\"left_left\":\n            await self._arm_reset_left_left(self.second_arm_port,initial_postition_deg=initial_pos_angle)\n\n    async def first_arm_reset(self,initial_position=True):\n        self.first_arm_after_reset_initialized=initial_position\n        initial_pos_angle=150 if initial_position else 0\n        await self._arm_reset_back_right(self.first_arm_port,initial_postition_deg=initial_pos_angle)\n\n    async def second_arm_up(self,degree=200,speed=700):\n        if self.cfg[\"second_arm_motor_position\"]==\"top_left\":\n            await self.move_arm_relative(self.second_arm_port,abs(degree),speed)\n        elif self.cfg[\"second_arm_motor_position\"]==\"left_left\":\n            await self.move_arm_relative(self.second_arm_port,-abs(degree),speed)\n        myprint(\"second_arm_up done\")\n\n\n    async def second_arm_down(self,degree=200,speed=700):\n        if self.second_arm_after_reset_initialized == False:\n            if degree == 200: degree+=150 #add skipped initial postion deg first time when arm is down\n            self.second_arm_after_reset_initialized=True\n\n        if self.cfg[\"second_arm_motor_position\"]==\"top_left\":\n            await self.move_arm_relative(self.second_arm_port,-abs(degree),speed)\n        elif self.cfg[\"second_arm_motor_position\"]==\"left_left\":\n            await self.move_arm_relative(self.second_arm_port,abs(degree),speed)\n        myprint(\"second_arm_down done\")\n\n    async def first_arm_up(self,degree=200,speed=700):\n        await self.move_arm_relative(self.first_arm_port,abs(degree),speed)\n        myprint(\"first_arm_up done\")\n\n    async def first_arm_down(self,degree=200,speed=700):\n        if self.first_arm_after_reset_initialized == False:\n            if degree == 200: degree+=150 #add skipped initial postion deg first time when arm is down\n            self.first_arm_after_reset_initialized=True\n\n        await self.move_arm_relative(self.first_arm_port,-abs(degree),speed)\n        myprint(\"first_arm_down done\")\n\n    '''\n        async def second_arm_up(self,degree=130):\n            await motor.run_to_absolute_position(self.second_arm_port,degree,200,direction=motor.CLOCKWISE)\n            myprint(\"second_arm_up done\")\n\n\n        async def second_arm_down(self,degree=200):\n            await motor.run_to_absolute_position(self.second_arm_port,degree,200,direction=motor.COUNTERCLOCKWISE)\n            myprint(\"second_arm_down done\")\n\n        async def first_arm_up(self,degree=10,speed=200,force=False):\n            #degree = (degree+self.first_arm_init_deg)%360\n            cur_pos=motor.absolute_position(self.first_arm_port)\n            print(\"first_arm_up: cur_pos:\",cur_pos)\n            #hack needed sometime motor does overdrive\n            if not force and (cur_pos> 350 or cur_pos < 25): return\n            await motor.run_to_absolute_position(self.first_arm_port,degree,speed,direction=motor.CLOCKWISE)\n            myprint(\"second_arm_up done\")\n\n\n        async def first_arm_down(self,degree=180,speed=200,acce=1000):\n            #degree = (degree+self.first_arm_init_deg)%360\n            await motor.run_to_absolute_position(self.first_arm_port,degree,speed,direction=motor.COUNTERCLOCKWISE,acceleration=acce)\n            myprint(\"second_arm_down done\")\n    '''\n\n    async def sleep(self,sleep_ms):\n        await runloop.sleep_ms(sleep_ms)\n\n\n\nclass FLL2024SubmergedMissions(FLLBaseLib):\n    def __init__(self, cfg):\n        super().__init__(cfg)\n\n    async def robot_arm_reset(self):\n        #await self.first_arm_reset()\n        await self.second_arm_reset(initial_position=False)\n\n    async def go_between_launch_zones(self):\n        await self.move_forward(200,velo=700)\n\n    async def mission_scoop1_WS_20(self):\n        await self.move_forward(20)\n        await self.turn_right(30)\n        await self.move_forward(50)\n        await self.turn_left(115)\n        await self.move_forward(10)\n        await self.turn_left(65)\n        await self.move_forward(60)\n\n    async def mission_9_UE_20_10_old(self):\n        speed=660\n        #await self.second_arm_reset()\n        #await self.move_forward(5)\n        await self.turn_left(46, correct_error=False)\n        await self.move_forward(47)\n        await self.move_backward(15,velo=660)\n        await self.turn_left(40)\n        await self.move_forward(25)\n        await self.turn_right(55)\n        await self.move_forward(30)\n        #await self.back_arm_up()\n\n\n        #next mission to immersive exp\n\n    async def mission_5_AF_30(self):\n\n        #await self.second_arm_reset()\n        #await self.second_arm_down(160)\n        await self.second_arm_down()\n        #await self.second_arm_up(40)\n        await self.move_forward(115,750)\n        await self.turn_left(10)\n        await self.turn_right(100)\n        await self.move_forward(20)\n        await self.second_arm_up(360)\n        await self.second_arm_down()\n        await self.second_arm_up(360)\n        await self.second_arm_down(330)\n        await self.move_backward(20)\n        await self.turn_right(37) #40\n        await self.move_forward(75,1000)\n        await self.turn_right(50) #48\n        await self.move_forward(80,700)\n\n\n\n\n        #await self.move_backward(90,1000)\n\n\n    async def mission_11_SD_20_10(self):\n\n        await self.second_arm_up(200)\n        await self.move_forward(20)\n        await self.turn_left(26)\n        await self.move_forward(62,900)\n        await self.second_arm_down(205,200)\n        await self.move_backward(70,1000)\n        #await self.turn_right(38)\n        #await self.second_arm_down(75)\n        #await self.move_forward(6)\n        #await self.second_arm_down(7)\n        #await self.turn_right(120)\n        #await self.move_forward(12)\n        #await self.turn_right(70)\n        #await self.move_forward(60,1000)\n\n    async def mission_13_Change_Lanes_20(self):\n\n        #await self.second_arm_reset(initial_position=False)\n        await self.second_arm_down()\n        await self.move_forward(12)\n        await self.turn_left(46)\n        await self.move_forward(25)\n        await self.turn_right(77.5)\n        await self.move_forward(14)\n        #original 23\n        await self.second_arm_up()\n        await self.turn_right(70)\n        #await self.move_backward(0)\n        await self.turn_right(70)\n        #await self.move_backward(25,1000)\n        #await self.turn_right(40)\n        #await self.second_arm_up()\n        await self.move_forward(40,1000)\n    \n    async def mission_9_UE_20_10(self):\n\n        await self.second_arm_down()\n        await self.move_forward(50,600,1)\n        await self.move_backward(50,1000)\n\n        \n    async def mission_13_CSL_20(self):\n        speed=660\n        await self.second_arm_reset()\n        await self.second_arm_down()\n        await self.move_forward(12)\n        await self.turn_left(46)\n        await self.move_forward(22)\n        await self.turn_right(79.5)\n        await self.move_forward(10)\n        await self.second_arm_up()\n        await self.turn_right(70)\n        await self.move_backward(10)\n        await self.turn_right(40)\n        await self.move_backward(5)\n        #await self.turn_right(20)\n        #await self.move_backward(10)\n\n    async def mission_1_CN_20_10_2_Shark_20_10_CR_20_15_6_30_working_function(self):\n        await self.second_arm_reset()\n        await self.move_forward(66,700)\n        await self.turn_left(45)\n        await self.second_arm_down() #18\n        await self.move_backward(2)\n        await self.second_arm_up() #325\n        await self.move_backward(9)\n        await self.turn_right(70)\n        await self.move_forward(14)\n        await self.second_arm_down()#20\n        await self.second_arm_up()\n        #await self.move_backward(3)\n        await self.turn_left(25)\n        await self.move_backward(10)\n        await self.turn_right(73)\n        await self.move_backward(13)\n        await self.move_forward(12)\n        await self.turn_left(50)\n        await self.move_backward(50,700)\n\n\n    async def mission_1_CN_20_10_2_Shark_20_10_CR_20_15_6_30(self):\n        #await self.second_arm_reset()\n        await self.move_forward(68,700)\n        #await self.move_forward(66,700)\n        await self.turn_left(45)\n        await self.second_arm_down() #18\n        await runloop.sleep_ms(500)\n        #return\n        await self.move_backward(3)\n        await self.second_arm_up() #325\n        await self.move_backward(9)\n        await self.turn_right(69)\n        #await self.turn_right(70)\n        await self.move_forward(12)\n        #await self.move_forward(13)\n        await self.second_arm_down()#20\n        await self.second_arm_up()\n        #await self.move_backward(3)\n        await self.turn_left(25)\n        await self.move_backward(10)\n        await self.turn_right(79)\n        #await self.turn_right(77)\n        await self.move_backward(13)\n        await self.move_forward(10)\n        await self.turn_right(30)\n        #await self.turn_right(50)\n        await self.second_arm_down()\n        await self.move_forward(11,500)\n        await self.second_arm_reset()\n        await self.turn_left(75,700)\n        await self.move_backward(65,700)\n\n\n\n\n\n\n\n    async def mission_14b_15(self):\n        await self.move_forward(40,600)\n        await self.move_backward(40,600)\n\n\n\n    async def mission_15_RV_20_30(self):\n        await self.move_forward(8*2.5,velo=700)\n        await self.move_forward(33*2.5,velo=700,steer=-3)\n        #await self.move_forward(21*2.5,velo=700,steer=-5)\n        await self.move_backward(6*2.5,velo=700)\n        await self.turn_left(30)\n        await self.move_forward(16*2.5,velo=700)\n        await self.turn_right(45)\n        await self.move_forward(24*2.5,velo=700)\n\n    async def mission_scoop(self):\n        await self.move_forward(10)\n        await self.turn_left(23)\n        await self.move_forward(60)\n        await self.turn_left(70,speed=150)\n        await self.move_forward(100,700)\n        await self.turn_left(15)\n        await self.move_forward(23)\n        await self.turn_left(77)\n        await self.move_forward(40)\n        await self.turn_right(60)\n        await self.move_forward(10)\n\n    async def race1(self):\n        await self.mission_scoop1_WS_20()\n\n    async def race2(self):\n        await self.mission_1_CN_20_10_2_Shark_20_10_CR_20_15_6_30()\n        #await self.mission_15_RV_20_30()\n        #await self.mission_9_UE_20_10()\n\n    async def race3(self):\n        #await self.mission_1_CN_20_10_2_Shark_20_10_CR_20_15()\n        await self.mission_14b_15()\n\n    async def race4(self):\n        await self.mission_15_RV_20_30()\n\n    async def race5(self):\n        await self.mission_5_AF_30()\n        #await self.mission_scoop()\n\n    async def race6(self):\n        await self.mission_13_Change_Lanes_20()\n        #await self.mission_13_CSL_20()\n        #await self.mission_scoop1_WS_20()\n\n    async def race7(self):\n        await self.mission_9_UE_20_10()\n\n    async def race8(self):\n        await self.mission_11_SD_20_10()\n\n    async def race9(self):\n        pass\n\n    async def mission_1_SB_20_10(self):\n      await self.move_forward(28,velo=700)\n      await self.move_backward(10,velo=700)\n      await self.move_forward(4,velo=700)\n      await self.sleep(100)\n      await self.turn_right(20,speed=700)\n      await self.move_forward(3,velo=1000)\n      await self.turn_left(50,speed=1000)\n      await self.move_backward(25,velo=1000)\n      #This mission is consistent and good WARNING: DON'T FIX\n\n    async def test(self):\n        await self.mission_1_SB_20_10()\n        return\n        await self.move_forward(10)\n        await self.second_arm_reset(initial_position=False)\n        await self.second_arm_down()\n        await self.second_arm_up()\n        await self.second_arm_down()\n        return\n        await sound.beep()\n        await self.second_arm_up(degree=200)\n        await sound.beep()\n        await self.second_arm_reset()\n        await self.second_arm_down()\n        await self.second_arm_up()\n\n\n        return\n        #total 200 degrees freedom of movement\n        await self.second_arm_up(degree=100)\n\n        return\n        await self.second_arm_reset()\n        return\n        await self.second_arm_down()\n        await sound.beep()\n        return\n        #total 200 degrees freedom of movement\n        await self.second_arm_up(degree=100)\n        await sound.beep()\n        await self.second_arm_up(degree=100)\n        await sound.beep()\n        await self.second_arm_down(degree=100)\n        await sound.beep()\n        await self.second_arm_up(degree=100)\n\n        pass\n\n\n\n\n\nasync def main():\n    # write your code here\n    #light_matrix.write(\"Hi!\")\n    cfg_ls={\n        \"left_wheel_port\":port.A,\n\n        \"right_wheel_port\":port.E,\n        \"first_color_sensor_port\":port.B,\n        \"second_color_sensor_port\":port.F,\n        \"first_arm_port\":port.D,\n        \"second_arm_port\":port.C, #port.D\n        \"first_arm_motor_position\":\"back_right\",\n        \"second_arm_motor_position\":\"top_left\"\n        }\n    cfg_cc={\n        \"left_wheel_port\":port.C,\n        \"right_wheel_port\":port.B,\n        \"first_color_sensor_port\":port.A,\n        \"second_color_sensor_port\":port.D,\n        \"first_arm_port\":port.F,\n        \"second_arm_port\":port.E, #port.D\n        \"first_arm_motor_position\":\"top_right\",\n        \"second_arm_motor_position\":\"left_left\"\n        }\n    cfg=cfg_ls\n    fll_match_missions=FLL2024SubmergedMissions(cfg)\n    #await ls_robot.follow_line(10000)\n\n    test=True\n    race1=False\n    race2=False\n    race3=False\n    race4=False\n    race5=False\n    race6=False\n    race7=False\n    race8=False\n    race9=False\n    arm_reset=False\n    if arm_reset:\n        await fll_match_missions.robot_arm_reset()\n    #test\n    if test:\n        await fll_match_missions.test()\n        return\n    #test done\n    #race 1\n    if race1:\n        await fll_match_missions.race1()\n    #race 1 ends\n\n    #race 2\n    if race2:\n        await fll_match_missions.race2()\n    #race 2 ends\n\n    #race 3\n    if race3:\n        await fll_match_missions.race3()\n    #race 3 ends\n\n    #race4\n    if race4:\n        await fll_match_missions.race4()\n\n    #race 5\n    if race5:\n        await fll_match_missions.race5()\n\n    #race6\n    if race6:\n        await fll_match_missions.race6()\n\n    if race7:\n        await fll_match_missions.race7()\n\n    if race8:\n        await fll_match_missions.race8()\n\n    if race9:\n        await fll_match_missions.race9()\n    #races done\n\n\n\n    if False:\n        myprint(\"calling move reverse\")\n        await fll_match_missions.move_backward(60,velo=1110)\n        myprint(\"calling move fwd\")\n        await fll_match_missions.move_forward(60,velo=1110)\n        #await runloop.sleep_ms(100)\n        myprint(\"calling move turn left\")\n        #await fll_match_missions.turn_left(90,use_gyro=False,correct_error=True,speed=600)\n        await runloop.sleep_ms(500)\n        myprint(\"calling move turn right\")\n        #await fll_match_missions.turn_right(90,use_gyro=False,correct_error=True,speed=600)\n        #await fll_match_missions.turn_right(90,use_gyro=True)\n        myprint(\"calling move end of main\")\n    sys.exit(0)\n\n#main()\nrunloop.run(main())\n"}